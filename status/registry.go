package status

import (
	"context"
	"github.com/palantir/witchcraft-go-health/conjure/witchcraft/api/health"
	"github.com/palantir/witchcraft-go-health/status"
	"sync"
)

type HealthCheckKey string

// HealthCheckRegistry is a dynamic and thread safe collection of health checks indexed by string keys.
// It exposes all underlying health checks by using a CombinedHealthCheckSource.
// The combination of the provided health checks is done in the order they were registered.
// In other words, if multiple check types collide, the one that was generated by the latest registered health check source will be used.
// It is useful for adding extra health checks after a server has been initialized.
type HealthCheckRegistry interface {
	status.HealthCheckSource
	Register(HealthCheckKey, status.HealthCheckSource)
	Unregister(HealthCheckKey)
	Get(key HealthCheckKey) (status.HealthCheckSource, bool)
}

type HealthCheckSourceRegistry struct {
	mutex    sync.RWMutex
	registry map[HealthCheckKey]status.HealthCheckSource
}

// NewHealthCheckSourceRegistry creates a new HealthCheckRegistry.
func NewHealthCheckSourceRegistry() *HealthCheckSourceRegistry {
	return &HealthCheckSourceRegistry{
		mutex:    sync.RWMutex{},
		registry: make(map[HealthCheckKey]status.HealthCheckSource),
	}
}

func (h *HealthCheckSourceRegistry) HealthStatus(ctx context.Context) health.HealthStatus {
	h.mutex.RLock()
	defer h.mutex.RUnlock()

	sources := make([]status.HealthCheckSource, 0, len(h.registry))
	for _, source := range h.registry {
		sources = append(sources, source)
	}

	return status.NewCombinedHealthCheckSource(sources...).HealthStatus(ctx)
}

func (h *HealthCheckSourceRegistry) Register(key HealthCheckKey, source status.HealthCheckSource) {
	h.mutex.Lock()
	defer h.mutex.Unlock()
	h.registry[key] = source
}

func (h *HealthCheckSourceRegistry) Unregister(key HealthCheckKey) {
	h.mutex.Lock()
	defer h.mutex.Unlock()
	delete(h.registry, key)
}

func (h *HealthCheckSourceRegistry) Get(key HealthCheckKey) (status.HealthCheckSource, bool) {
	h.mutex.Lock()
	defer h.mutex.Unlock()
	source, ok := h.registry[key]
	return source, ok
}
